        // w kontrolerze tylko jeden serwis musi byc wywolywany, w innych serwisach mamy robic te wszystkie rzeczy
        //  odpowiedzialnosc kontrolera - przyjac requesta, zwalidowac, przekazac do controllera i odeslac odpowiedz.


        // 1 SERWIS +- 1 validator - ew login


//Paweł Kadłubański
//17:21
//https://huggingface.co/
//Paweł Kadłubański
//17:27
//https://hub.docker.com/r/minio/minio
//
//
//




MINIO SERVER STARTUP


.\minio.exe server C:\minio --console-address :9001






Dobra, chce aby byl FileService i on mial atrybuty takie jak
MinioService, OcrService
i zeby uploadFile metoda w FileService wywolywala najpierw metode MinioService.uploadFile,
potem zeby OcrService mapowal to na odpowiednia encje InvoiceDTO, a potem Mapperem z DTO na Invoice i zapisywal do bazy danych
(zapis do bazy danych zwroci ten obiekt)



//
//		String apiKey = "bcb1045014fd0a1fa01e4a1c71a50c5f";
//		String filePath = "C:\\Users\\krpia\\Downloads\\AccountingHelperOfficial\\src\\main\\resources\\static\\PL_Invoice.png";
//
//		MindeeClient mindeeClient = new MindeeClient(apiKey);
//
//		// Load a file from disk
//		LocalInputSource inputSource = new LocalInputSource(new File(filePath));
//
//		// Parse the file asynchronously
//		AsyncPredictResponse<InvoiceV4> response = mindeeClient.enqueueAndParse(
//				InvoiceV4.class,
//				inputSource
//		);
//
//		System.out.println(response.getDocument().get().getInference().getPrediction().getBillingAddress().getValue());


//
//		// pola potrzebne do price
//		System.out.println(response.getDocument().getInference().getPrediction().getTotalAmount().getValue());
//		System.out.println(response.getDocument().getInference().getPrediction().getLocale().getCurrency());
////		System.out.println();
////		System.out.println();
////		System.out.println();
////
////
////		//pola potrzebne do Company
////		System.out.println(response.getDocument().getInference().getPrediction().getSupplierName().getValue());
////		System.out.println();
////		System.out.println();
////		System.out.println();
////		List<CompanyRegistrationField> supplierCompanyRegistrations = response.getDocument().getInference().getPrediction().getSupplierCompanyRegistrations();
////		for (CompanyRegistrationField supplierCompanyRegistration : supplierCompanyRegistrations) {
////			System.out.println(supplierCompanyRegistration.getValue());
////
////		}
////
////
////		System.out.println();
////		System.out.println();
////		System.out.println();
////		//pola potrzebne do Address
//		System.out.println(response.getDocument().getInference().getPrediction().getSupplierAddress().getValue());


		// Print a summary of the response
//		System.out.println(response.toString());






(Database authentication)
//spring security - autentykacja w oparciu o baze danych - w klasie konfiguracyjnej ktora tworzy spring context, to
on moze znalezc zytkownika ktorego w headerze kazdego requesta (gdzie bedzie id ) kazdego uzytkownika



pakiet validations i tam zrobic validatora do nipu, gdzie przy dodawaniu uzytkownika / zczytywania z ocr
po prostu to wywolywac i sprawdzic manualnie
- moze byc metoda statyczna ktora bierze stringa (regex)






spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.url=jdbc:mysql://localhost:3306/accounting
spring.datasource.username=root
spring.datasource.password=mysql
spring.jpa.hibernate.ddl-auto=create




# Enable Hibernate SQL logging
spring.jpa.show-sql=true

# Format the SQL output to make it more readable
spring.jpa.properties.hibernate.format_sql=true




#minio
minio.url=http://localhost:9000
minio.access.name=minioadmin
minio.access.secret=minioadmin

#MINDEE
mindee.key=${MINDEE_API_KEY}




#OPENAI API
#spring.ai.openai.chat.options.model=gpt-4
spring.ai.openai.api-key=${OPENAI_API_KEY}
spring.ai.openai.base-url=https://api.openai.com/v1
spring.ai.openai.image.enabled=true








adnotacja ValidateBy na klasie? - sprawdzic,




adnotacje pattern, validate one moga dzialac tylko jak sie je wywoluje przez resta





do testowania
mvc test

webtestclient

restasure -> ten moze najlepszy





SpringScheduler - pozwala wykonywacz zadania periodyczne - on wtedy odpala ta funckje co tyle ile zdefiniujemy

w tym wydarzeniu cronowym musimy napisac metoda, ktora wykonuje sie MAKSYMALNIE 1 RAZ dziennie, potem iddzie do bazy danych
i sprawdza ktory due date do zaplacenia ma do 3 dni. To zwraca liste faktur, ktora potem mu tez zwracamy. To wszystko dzieje sie
asynchronicznie, wiec potem musimy wyslac maila do uzytkownika


zanim przejdziesz do wysylania maili, to mozesz miec inny endpoint przy logowaniu - getNotification

po logowanie jak jest success to wykonujemy 2gi endpoint - notification i od razu user dostaje informacje ktore  go interesuja-
-due date do zaplacenia czy inne




Strimlit - do jakiejs prostej wersji frontendu

